---
title: "3.2 可编程阶段"
keywords: sample homepage
tags: [getting_started]
sidebar: rtr
layout: book
permalink: rtr_ch3_shader_stage.html
summary: GPU
---

### 可编程着色器

现代着色器（就是那些支持着色模型4.0，DX10以上）使用通用着色核心。就是说顶点、几何、像素着色器都共享一套编程模型。我们在本书中会区分通用着色核心和统一着色器，前者的功能描述是对开发者可见的，后者在一些GPU架构上工作的很好。详见18.4.通用着色核心是API；而统一着色器是GPU特性。早期GPU上，顶点和像素着色器之间没什么共性，也没有几何着色器。它的大部分的设计来自更老的硬件，在更老的硬件上，大部分元素的功能要么更简单，要么没有该功能，没有什么根本上的不同。现在，让我们把注意力放在着色器模型4.0上，比较老的GPU着色模型等后面再谈。

完整的讨论全部变成模型已经超出了本书的范围，而且已经有很多文档、书还有网站已经做过了。不过，少量的讨论是计划内的。**着色器编程使用的是一种C风格的着色语言，例如HLSL，Cg以及GLSL**。他们被编译成非机器依赖的汇编语言，也叫中间语言(IL)。以前的着色器模型可以直接用汇编语言编写，但是从DX10开始，这种语言只作为调试输出了。这种汇编语言会被单独转换成实际的机器语言，一般是在驱动中完成。这种结构能够兼容不同的硬件实现。这种汇编语言可以被视为一种虚拟机，是着色语言编译器的编译目标。

虚拟机是多种寄存器和数据源的处理器，使用一套指令集来编写。因为很多图形操作都是在短向量上完成（长度最多到4），所以处理器有着4路SIMD（单指令多数据）功能。每个寄存器包含四个独立数值。32位单精度浮点数和向量都是基础数据类型，32位整形数据是最近才开始支持的。浮点数据的向量比较有代表性的是位置点(xyzw)、法线、矩阵行数据、颜色(rgba)以及纹理坐标(uvwq)。整型一般用在计数器、索引或者位蒙版(mask)。组合数据类型如结构体、数组以及矩阵等也可以支持。**为了方便向量的使用，一种鸡尾酒魔法的功能，可以任意重组向量的元素**。就是说向量的元素可以按需求以任意顺序来使用。同样，也可以只使用向量的某些元素。

**一次绘制调用（draw call，以下简称DC)**，就是调用图像API来绘制一组图元，而整个图形流水线都会运作起来。每个可编程着色阶段都有两种类型的输入数据：不变的输入(uniform)，就是整个绘制期间，该数据保持不变（不同的DC间可以变化）；可变输入，着色器处理的每个顶点或像素需要的数据都不相同。

纹理可以认为是一种特殊的uniform数据，它永远都是传递一个图片给面片，但同时它又是任意大小的列表数据。需要注意的是，虽然着色器可以接受多种输入，因为有不同的寻址方式，但是输出数据却是非常受限。这是着色器程序和运行在通用处理器上的普通程序之间非常重要的区别。

潜在的虚拟机为每种输入输出类型提供特别的寄存器。Uniform数据被存储在只读的常量寄存器或常量缓冲中，因为整个DC期间他们的内容不会改变。常量寄存器比可变寄存器数量不知道多到哪里去了。这是因为需要针对每个顶点和像素单独存储可变数据，**而uniform输入只存储一次，在整个绘制期间要重复使用**。虚拟机还有普通的临时寄存器，一般用来放一些计算的临时数据。所有类型的寄存器都能被临时寄存器使用下标索引到。图3.2展示了着色器虚拟机的输入输出数据。

![图](/images/RTR3.03.02.png)

图形计算的常见操作在现代GPU上都能有效的运行。举例来说，操作最快的是标量和向量的乘法、加法及组合，类似多个相加和点积。其他的操作如倒数、开方、sin、cos、求幂、对数等就相对比较耗时，但也是相当快的。纹理操作（详见第六章）非常高效，但它们的表现可能会受限于存取的时间。着色语言使用 * 和 + 号实现前面说到的这些操作（加法和乘法相关的）。其他的一些操作就是通过函数来完成了，比如`atan(), dot(), log()`以及其他函数。还有一些基础的函数来完成比较复杂的操作，比如向量的规范化和反射、叉乘、矩阵转置和行列式等等。

术语<font color="tomato">流控制</font>表示分支指令来控制代码的执行流程。这些指令通常用于实现高级语言结构中的if和case语义，以及不同类型的循环。着色器支持两种流控制。基于Uniform输入值的<font color="tomato">静态流控制</font>分支。静态流控制的主要用处在于统一个着色器可以用在不同的情形下（例如不同数量的灯光）。基于变量输入的<font color="tomato">动态流控制</font>，它比静态流控制强力很多，但也比较耗时，特别是在着色器执行期间分支的变化不固定时。着色器会处理批量顶点或像素，详见18.4.2章节。如果其中一部分顶点或像素走的是`if`分支，而另一部分走的是`else`分支，所有顶点或像素实际上都要花费两个分支的时间（虽然未走的分支被抛弃了）。([知乎链接](https://zhuanlan.zhihu.com/p/33260382)有详细描述这种情况)

着色程序可以在程序加载之前或者运行时进行离线编译。不管使用哪种编译器，我们都可以配置不同的输出文件以及优化等级。编译后的着色器使用文本存储，被驱动传递给GPU。


