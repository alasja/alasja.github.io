---
title: "5.6 走样和反走样"
sidebar: rtr
layout: book
permalink: rtr_ch5_aliasing.html
---

### 5.6 走样和反走样
想象一个很大的黑色三角形在白色背景中缓慢移动。屏幕的网格点被三角形覆盖到，则该点逐渐平滑的显现出来。但是通常各种类型基础的渲染器都是在网格点的中心北覆盖的瞬间，颜色从白变成黑。标准GPU的绘制都是这样。可见图5.18的左图

![图](/images/RTR3.05.18.png)
图5.18 <font color="gray">上面一行的图片展示的是在不同抗锯齿级别下，三角形、点、线的成像。下面一行是上面图像的放大版本。左侧图每个像素点只有一个采样点，也就是没有任何抗锯齿效果。中间图像每个像素点则是4个网格采样点，右图则是使用8个采样点（4*4的棋盘，译：这不应该是16么？）。这些图像使用`InfiniteReality`渲染</font>

多边形在像素中只有覆盖和不覆盖两种状态。线条绘制有同样的问题。边缘因此会有一些锯齿的形状，这种不真实的表现被称为“锯齿”，在动画中就会变成“蠕动的毛毛虫(the crawlies)”。这些问题的正式的名字是`“走样(aliasing)”`，去除走样的技术被称为`反走样(antialiasing)`。

采样理论和数字过滤是一个很大的主题，可以在参考文献[422,1035,1367]中看到。作为渲染的关键领域，我们会介绍一些相关的基础理论。然后我们就主要关注，在实时渲染中如何减少走样的问题。


### 5.6.1 采样和过滤理论
渲染图片实际上是一个采样的过程。这是因为图片的生成过程就是从三维场景中采样，来决定图片（不连续的像素列表）的每个像素颜色值。要使用纹理映射（见第六章），纹理需要针对不同的坐标重新采样得到合适的结果。为了得到动画中的图像序列，动画一般使用固定的时间间隔来采样。本节的主题四介绍采样、重建和过滤。为了简单起见，大部分材质都在一维下表现。这些概念很自然的可以扩展到二维，所以也就可以被用到二维图片的使用中。


![图](/images/RTR3.05.19.png)
图5.19

图5.19展示了一个连续的信号，如何使用固定的间隔采样，这是离散化的。采样的目的是数字化的表达信息。采样之后，信息的数量降低了。不过采样的信号最终还是需要`重建(recostructed)`成原始信息的样子。这是对采样信号使用`过滤(filtering)`来实现的。

当采样结束后，就可能发生走样。这是一个不期望的效果，我们需要处理它以产生更好的图像。现实生活中，一个经典走样的例子是使用摄像机来拍摄纺纱轮[404]。因为轮子转动速度要比相机记录的速度快，所以轮子可能表现出缓慢的旋转(顺着转或者倒着转)，甚至看起来根本不在转。这种现象可在图5.20中看到。这种结果是因为轮子的图像的拍摄，使用了一些不同的时间间隔，这也被称为`暂时走样(temporal aliasing)`

![图](/images/RTR3.05.20.png)
图5.20，采样使用不同的时间间隔，获取的图像不一样，以至于最后看起来轮子的表现也不同。

计算机图形中，走样比较常见的例子是栅格化线条或多边形边缘、闪烁的高光、以及纹理使用棋盘模式采样的各类锯齿（可见6.2.2节）。

![图](/images/RTR3.05.21.png)
图5.21 <font color="gray">蓝实线表示源信号，红点是离散的固定间隔获取的采样点，绿色虚线是重建的信号。上面展示了一个非常低的采样速率。尽管如此，重建的信号显示了一个比较低的频率。下面的采样速率恰好是源信号频率的两倍，重建的信号变成了一条水平线。这可以证明即便采样速率只是轻微的改变，也可能完美的重建图像 </font>

当信号采样的频率太低的时候，就会发生走样。采样的信号的频率可能出现比源信号的频率低。这可以在图5.21中看到。`一个被正确采样的信号（也就是，能够使用采样信号重建源信号），采样的频率需要大于源信号极限频率的两倍`。这通常被称为`采样定理(sampling theorem)`，这个采样频率被称为`Nyquist 速率`[1035,1367]或者`Nyquist极限`[1332]。`Nyquist极限`也可以在图5.20中看到。定理中使用的术语`极限频率`表示信号是`频带限制(bandlimited)`的，也就是说一个特点极限下，不是任何频率都可以的。从另一个角度来看就是，在两个相邻的采样点之间，信号需要足够的平滑。

一个采用点采样绘制的三维场景，通常没有什么`频带限制`。多边形的边缘，引用的边缘，以及其他现象产生的信号都是不连续的，所以他们的频率也就没有什么限制[170]。而且不论采样点有多么密集，对象也有可能小到无法采样。因此，在渲染场景的时候，没法完全避免走样问题。尽管如此，有时也需要知道信号何时是`频带限制`的。一个例子就是当纹理应用到表面的时候。可以比较纹理采样的频率和像素采样频率。如果这个频率低于`Nyquist极限`，那么不需要做什么操作就可以得到正确的纹理采样。如果这个频率太高，则需要使用纹理使用的采样频率（见6.2.2节）。


### 5.6.1.1 重建 Reconstruction
给定一个频带限制的采样信号，我们要讨论如何从采样的信号还原出原始信号。为了完成这个，需要使用一个过滤器。图5.22展示三种常见的过滤器。需要注意的是过滤器的面积需要保持为1，否则就会出现拉伸效果。

![图](/images/RTR3.05.22.png)
图5.22

在图5.23中，`方格过滤器(box filter)`（相邻点）用来重建采样信号。这种过滤器非常糟糕，重建的结果变成了不连续的台阶。不过因为它的简单性，在计算机图像中也经常被使用。如图所示，方格过滤器替换每个采样点，然后缩放使过滤器的最高点对准采样点。这些缩放和转换函数的综合结果就是右边展示的重建结果。

![图](/images/RTR3.05.23.png)
图5.23

方格过滤器可以被其他任何过滤代替。在图5.24中，`帐篷过滤器(tent filter)`也称为`三角过滤器(triangle filter)`也可以用来重建采样信号。注意这个过滤器在相邻的采样点之间做线性插值，所以它比方格过滤器要好一点，因为结果信号比较连续。

![图](/images/RTR3.05.24.png)
图5.24

尽管如此，使用三角过滤器重建的信号还是不够平滑；在采样点的位置会发生突变。所以说三角过滤器不是个完美的过滤器。要得到一个完美的过滤，要使用一种`低通过滤器(lowpass filter)`。信号的一种频率部分是一个正弦波：$sin(2 \pi f)$，f就是这个部分的频率。给定这个条件，一个低通过滤器能够过滤掉所有高于，过滤器设定的频率，的频率部分。直观的来说，低通过滤器过滤掉信号中尖锐的部分，也就是过滤器使它变得平滑。低通过滤器的思想就是正弦波过滤器（图5.22最下面），使用正弦波过滤器来重建信号可以得到一个平滑的结果，如图5.25所示：

$$
sinc(x) = \frac{sin(\pi x)}{\pi x}.   \tag{5.15}
$$

![图](/images/RTR3.05.25.png)
图5.25

我们可以看到这个采样中，信号有比较高频率的的部分（尖锐的变换），低通过滤器则将高频率部分移除了。事实上，这个`sinc`过滤器会移除所有大于采样速率一般的频率部分。等式5.15中展示的`sinc`过滤器函数，在采样平率1.0的时候就是一个完美的重建过滤器（也就是，被采样信号的最大频率低于0.5）。更通用的情况是，假设被采样信号的频率是$f_s$，则两个采样间隔为$1/f_s$。这种情况下，完美重建过滤器就是$sinc(f_s x)$，它会移除所有大于$f_s/2$的平率部分。这在对信号的重采样中很有用（见下一节）。尽管如此，sinc的过滤宽度是无限制的，有时甚至可以是负的，在实际应用中并非那么有用。

一个有用的方法是低质量的方格过滤器和三角过滤器的综合平均，另一个是不太实际的`sinc`过滤器。大部分广泛使用的过滤函数[872,941,1276,1367]都在这种极端情况中。所有的这些过滤函数都会跟sinc函数有些近似的地方，但影响的像素数量有限制。跟sinc函数最相似的过滤器，在区域内有部分是负值。应用程序中，负值是不期望的也不现实的，通常会使用没有负值部分的过滤器（通常是参考高斯过滤器来构建，要么是像高斯曲线，要么从高斯曲线推导得出）。10.9节会更多的讨论过滤器及使用的细节。

当使用任意的过滤器之后，都会得到一个连续的信号。不过，在计算机图形上我们没法直接表现连续的信号，但是我们可以用他们来对连续的信号`重采样`，以得到不同的大小，也就是要么扩大，要么缩小。下面就开始讨论这个。

### 5.6.1.2 重采样 Resampling
重采样是用来`放大(magnify)`或者`缩小(minify)`信号。假设原始采样点位于整数坐标点(0,1,2...)，就是采样的间隔是1。进一步假设在重采样之后，我们希望得到的采样点的固定间隔为*a*。对于 *a > 1*，则发生缩小（降低采样），对于*a < 1*，则发生放大（高采样率）。

`放大(magnification)`在这两种情况中更简单，所以我们从它开始。假设被采样信号使用上一节的方法来重建。直观来说，信号现在被完美重建，也是连续的，现在需要的就是对重建的信号以目标间隔进行重采样。图5.26展示了这个处理过程。

![图](/images/RTR3.05.26.png)
图5.26

不过，这个技术没法用于缩小采样。源信号的频率太高了，所以没法避免走样的发生。如图5.27。我们可以对采样信号使用`sinc(x/a`来构建连续信号。之后，再使用目标间隔来重采样。换句话说，因为使用了`sinc(x/a)`函数来过滤，低通过滤器的宽度增加了，所以信号更多高频率部分被过滤掉了。正如图中所示，过滤宽度放大了一倍，用来降低重采样的频率到源采样频率的一半。如果对一个数字图像使用这个方法，它很像是先把它模糊（移除高频率），然后使用低频率来对图像重采样。

![图](/images/RTR3.05.27.png)
图5.27

有了采样和过滤器理论框架，我们现在就可以深入探讨实时渲染中使用的各种降低走样的算法了。

### 5.6.2 基于屏幕的反走样
多边形的边缘，在采样不够好的情况下，会产生比较明显的不真实。阴影边界界，高光，以及其他颜色变化明显的地方都可能会引起类似的问题。本节讨论的算法就是用于改善这种情况下的渲染质量。他们的通用流程是基于屏幕的，也就是说，他们是对流水线的输出采样来操作，不需要对被渲染的对象有任何依赖。

有些反走样专注于解决三角形的渲染。两个特别的例子是纹理走样和直线走样。纹理反走样会在6.2.2节讨论。直线反走样有多种表现形式。一种方式是把直线看成是一像素宽的四边形，跟他的背景混合；另一种是认为他是一个无限细，有光晕的透明对象；第三种是把它看做是一个平滑的纹理[849]。这些看待直线的方式，可以用于`基于屏幕(screen-based)`的反走样方案中，但特殊应用的线条反走样硬件可以提供更快，更高质量的渲染。`Nelson's`两个文章介绍了一个更彻底的解决方案来处理这个问题和相关情况。Chan 和 Durand的文章[170]中提供了一种特别的GPU预过滤线条的方案。

![图](/images/RTR3.05.28.png)
图5.28 (<font color="gray">左图中，每个像素中心只有一个采样点。因为三角形没有覆盖到那个采样点，所以像素是白的，即便像素的部分被覆盖到了。右边，像素有四个采样点，如图所示，三角线覆盖了两个采样点，结果像素是粉红色的。</font>)

在图5.18的黑色三角形例子中，一个问题是采样频率太低。每个像素格的中心为一个采样点，所以我们是否能看到那个像素取决于三角形是否覆盖到中心点。每个像素格上使用更多的采样点，然后使用一些方法来混合，可以计算出一个更合适的像素样色。如图5.28所示。

基于屏幕的反走样方案的更通用策略是，使用一种屏幕采样模式，然后给他们赋予权重，并累加到一起以得到最终的像素颜色*p*：

$$
p(x, y) = \sum_{i=1}^n w_i c(i, x, y).     \tag{5.16}
$$

其中n是单个像素格的采样点数量。函数`c(i, x, y)`是采样颜色，$w_i$是权重，范围是[0,1]，这样每个采样点都会对最终颜色做出贡献。采样位置则基于采样在序列中1,...n中的位置，函数使用像素的位置(x,y)的整数部分来做一些随机。换句话说，每个采样点在屏幕网格上采样的位置都不同，随机部分则使得每个像素之间的采样也不相同。在实时渲染系统中（以及其他大部分渲染系统）采样通常都是点采样。所以函数**c**可以认为是两个函数组合。首先函数`f(i,n)`检索浮点数的点$(x_f, y_y)$在屏幕上的位置，以确定采样点的位置。屏幕上对应的位置则会被采样，也就是说，那个特定点的样色被检索到。采样方法被选择，渲染流水线被配置来计算各个子像素位置的采样，一般基于每帧（或者是应用）的设置。

另一个变量是$w_i$，这是每个采样的权重。各个权重的和为1。大部分实时渲染系统都使用固定的权重，也就是，$w_i = \frac{1}{n}$。注意图形硬件的默认模式，就是仅在像素的中心有一个采样点，也是上面公式最简化的形式。仅有一个分量，它的权重为1，且采样函数**f**总是返回被采样像素的中心。

在单个像素点上计算超过一个采样点的反走样算法被称为`超采样(supersampling)（或者叫 过采样）`。概念上是很简单的，`全屏幕反走样full-scene antialiasing(FSAA)`以一个较高的分辨率来渲染场景，然后对相邻的采样点进行均值计算来得到最终的图像。举个例子，如果需要渲染一个1000*800像素的图像。如果你离屏渲染一个2000*1600大小的图像，然后对每个2*2区域的采样进行均值计算，得到的图像就是每个像素有4个采样点了。可以参考图5.29中2x2 grid部分。这个方法消耗比较大，因为每个子采样点都需要完整的着色和填充，以及每个采样点还有对应的Z缓冲数据。FSAA的主要优势是简单。另外，这个方法的低质量版本仅在单个轴上2次采样，所以也被称为1x2 或者 2x1超采样。

一个相关的方法是`累积缓冲(accumulation buffer)[474,815]`。这个方法没有使用一个大的离屏缓冲，而是使用跟目标图像使用相同的分辨率，不过颜色值使用更多位。要得到场景的2x2的采样，要生成4张图像，且视图要在x和y轴上移动半个像素。本质上来说，每个生成的图像都是对应网格上一个不同的采样点。这些图像在累积缓冲中累加到一起。在渲染之后，图像被均值计算了（本例中，就是除以4），然后绘制到显示器上。累计缓冲是OpenGL API的一部分[9,1362]。他们也能用于`运动模糊(motion blur)`特效中，这个效果中运动的物体会出现模糊状态，以及使用场景深度，不在相机焦点上的物体也出现模糊。尽管如此，每帧要多次渲染场景也是有额外开销的，以及需要拷贝结果到屏幕上，使得这个算法在实时渲染系统中都是开销比较大的。

![图](/images/RTR3.05.29.png)
图5.29

现代GPU没有专门的`累积缓冲`硬件，但是我们可以模拟它的效果，使用像素操作把多个不同的图片混合到一起[884]。如果累积缓冲只使用8位通道的颜色值，则`低字节(low-order)`的数据在混合的时候可能就会丢失了，可能会引起颜色条带。更高精度的缓冲（大部分硬件支持每个通道10到16个字节）可以避免这个问题。

累积缓冲比FSAA强（也超过后面要讲的A缓冲）的一个特点是采样点不用局限在像素点内的垂直模式。每个`通道(Pass)`都互相不依赖，所以可以使用交替采样的模式。一个旋转的正方形的采样模式可以是(0, 0.25), (0.5, 0), (0.75, 0.5), (0.25, 0.75)，让像素的水平和垂直方向有更高的分辨率。有时被称为`旋转网格超采样rotated grid supersampling(RGSS)`，这个模式在水平和垂直边缘有更高的反走样能力，这也是通常需要提高的部分。事实上，Naiman在他的文章中[919]展示了，人们通常是在垂直边缘或水平边缘被干扰。45度的斜边是另一个最常出问题的地方。图5.29展示了不同的采样模式如何影响渲染质量。

通过生成采样的超采样技术，完全是单独定义在计算着色、深度和位置上的。开销很大很整个效果却比较弱；特别是所有的采样都需要在像素着色器中完成。因此，DX中没有直接把`累积缓冲`作为一个反走样方法。`多重采样(Multisampling)`策略通过使用不同的序列，对不同类型的数据采样，来降低这个算法的高计算开销。多重采样在一个Pass中对一个像素进行多个采样，并共用一些计算（不想之前的算法那样）。在GPU硬件上，这些技术被称为`多重采样反走样(multisamle antialiasing MSAA)`，也经常被称为`覆盖采样反走样(coverage sampling antialiasing CSAA)`。

有些地方需要额外的采样，比如对象的边缘，高光，以及尖锐的影子等颜色变化剧烈的地方。阴影可以被软化和亮化，但是对象的边缘依然是一个主要的采样问题。MSAA可以在逐片元计算多个阴影采样时节约时间。像素的每个片元可能会有4个采样位置，每个都有各自的颜色很深度，但是着色器每个片元只计算一次。图5.30展示实际运用中的MSAA模式。

如果MSAA中所有的位置的采样点都被覆盖到，那么渲染着色的就是中心位置的采样点。不过，如果片元只覆盖到部分采样点，着色的采样点则是可以变化的。这么做是避免渲染到纹理边缘的外部。这种位置决定被称为`中心点采样centroid sampling`或`中心点插值centroid interpolation`，如果可用的话，则会自动在GPU中完成。

![图](/images/RTR3.05.30.png)
图5.30

MSAA不纯粹的超采样方案要快，因为片元只着色一次。它专注于对片元在像素上覆盖做采样，使用高频率的采样并在着色器中共享计算结果。不过，事实上对每个像素单独存储颜色和深度值并不是必须的。CSAA在这方面有优势，它只存储片元的覆盖部分，以较高的采样频率。每个子像素存储一个索引关联对应的片元。一个有限对象的表格（四个或八个）存储每个片元关联的颜色和深度值。比方说，一个表存储4个颜色值和深度值，每个子像素仅需要两个bit来存储这个表中的索引。理论上一个有16个采样点的像素可以有16个不同的片元，这种情况下CSAA则没法存储需要的信息，结果可能就是不真实的。大部分数据类型来说，一个像素中很少有超过四个完全不同的片元着色，所以这个方法在实践中表现的相当好。

从着色中分离覆盖率和深度存储的想法类似于`Carpenter提出的A缓冲[157]`，另一种类型的多重采样。这个算法通常用于软件中生成高质量的渲染，但不是交互级别的速度。在A缓冲中，每个多边形的渲染对每个全部或部分覆盖的屏幕网格，生成一个`覆盖蒙版coverage mask`。图5.31可以看到一个覆盖蒙版的例子。

![图](/images/RTR3.05.31.png)
图5.31

类似MSAA，多边形着色关联的覆盖蒙版，通常只在中心点位置的片元上计算一次，然后在其他采样中共享结果。深度值也是同样的方式计算和存储。有些系统会计算一对深度值，最小值和最大值。另外保持多边形的斜率，所以实际的深度值可以使用任何采样点位置计算得到，这可以让互相穿插的线段得以正确的绘制[614]。覆盖蒙版，着色，深度值，以及其他的一些信息共同组成了A缓冲的图元数据。

A缓冲与Z缓冲非常不同的一点是，一个屏幕网格点可以有任意多的图元。这些图元聚集在一起，隐藏的图元则被丢弃。比方说，一个不透明图元A的覆盖模板完全覆盖了图元B，并且A的最大深度比物体B最小深度还要小，那么B可以安全的丢弃掉。多个覆盖模板可以合并和同时使用。比方说，一个不透明图片覆盖像素的的一部分，另一个不透明图元覆盖了像素的另一部分，那么他们的模板可以逻辑上合并到一起，他们中较大的深度值用作合并后区域的深度值。有了这种合并的技术，图元通常会按深度来排序。根据不同的设计，这种合并可以在图元填充的时候发生，或者在着色和显示之前的最后一步操作。

当所有多边形都传递到A缓冲，像素要存储的颜色值就要被计算出来。这部分的完成取决于每个图元有多少蒙版可见，然后再乘以各自的权重并求和。图5.18是一个使用多重采样硬件的例子。透明效果是A缓冲的能力之一，也是这个时候完成。

虽然这听起来像是一个程序功能，很多把三角形渲染到深度值得技术可以用到硬件中来实现A缓冲[1362]。内存需求和计算量通常都比FSAA要低，因为A缓冲为每个像素存储了一些图元。这个方法的一个问题是半透明图元的存储可能是没有上限的。*Jouppi & Change[614]*发展了一种$Z^3$算法，这个方法中每个像素使用固定数量的图元。当到达存储限制的时候强制进行合并操作。*Bavoil等人[74,77]将这个方法一般化成他们的`K缓冲架构`。他们早期的论文也很好的综述了这方面的研究内容。

所有这些反走样方法都是如何让多边形更好的填充一个网格，他们都有一些限制。正如前面章节所说，场景中的物体在屏幕上可能会非常的小，就是说没有什么采样频率能够完美的捕获他们。所以，常规模式的采样总会有某些形式的走样。一个避免走样的方法是在像素上构建随机的采样点，每个像素采样的模式都不同。这被称为`随机采样(stochastic sampling)`，这个采样效果比较好的原因是，它把重复的走样效果加上了噪声，这是人的视觉系统更容易忽略的部分[404]。

最常用的随机采样方法叫做`jittering`，一种分层采样方法，工作方式如下。假设一个像素有n个采样。将像素区域分割成n个正方形区域，然后在这些正方形区域内再随机一个位置。见图5.32。像素最终的颜色则是这些采样的平均值。`N-rooks`采样也是一种分层采样方法，它把n个采样放到`n x n`的网格中，每一行每一列中都只有一个采样点[1169]。事实上，`N-rooks`模式已经用于无限接近真实中，因为它在水平和垂直边缘的表现非常好。为了这种架构，需要对每个像素使用相同的模式，并且是在子像素的中心（并非随机），所以它不会表现出随机采样。

![图](/images/RTR3.05.32.png)
图5.32

`AT&T Pixel Machines`和`Silicon Graphics' VGX`，以及更多最近`ATI's SMOOTHVISION`方案，使用一种叫做`交叉采样(interleaved sampling)`的技术。ATI的版本中，反走样硬件允许每个像素最多有16个采样点，以及最多16个不同的用户自定义采样模式来混合重复使用（比如，在一个4x4的像素块中，每个像素都可以有不同的模式）。在使用一个纯`jittering`方案中，采样模式也并不是每个像素都互不相同。尽管如此，`Molnar[894]`的文章，以及`Keller和Heidrich的文章[642]`，发现使用交错采样，对每个像素使用相同的模式，使得走样效果最小化了。见图5.33。这种技术可以认为是一种`累积缓冲`技术，都是重复使用采样模式，不过一个是跨越多个像素，一个是单个像素内。

![图](/images/RTR3.05.33.png)
图5.33

还有一些其他的采样和过滤方法。已知的最好的采样模式是`泊松分布采样(Poisson disk sampling)`，这个方法中，使用尽量小的距离来分割成不均匀分布的点[195,260]。Molnar展示了一种实时渲染的方法，其中采样没有权重，使用`泊松分布`模式和`高斯过滤核(Gaussian filtering kernel)` 来排列，

