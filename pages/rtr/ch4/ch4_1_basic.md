---
title: "基础变换"
sidebar: rtr
layout: book
permalink: rtr_ch4_basic.html
summary: 第四章.
---

### 变换

> What if angry vectors veer
> Round your sleeping head, and form,
> There's never need to fear
> Violence of the poor world's abstract storm.
>             -- Robert Penn Warren



变换是对实体（如点、向量或者颜色）的一种转变操作。对图形工作者来说，掌握变换非常非常重要。使用这个工具，你能设置位置、改变形状、对物体灯光相机做动画等。你也能确保所有的计算是在同一个坐标系统下，还可以使用不同的方式把对象投影到一个平面上。变换的操作其实比较少，但是他们却在实时图形中扮演着非常重要的角色，或者说，在所有的计算机图形中都很重要。

线性变换就是向量相加或与常数相乘。如下：

$$
	f(x) + f(y) = f(x + y), \\
	kf(x) = f(kx). \tag{4.1}
$$

比如说，$f(x) = 5x$就是一个变换，它把向量的每个元素放大5倍。这种变换就是线性变换，任何两个向量先放大五倍后相加，与先相加再放大五倍的结果一样。这与标量的乘法一致。这个函数称为缩放变换，它缩放对象的大小。旋转变换也是线性变换，它把向量绕原点旋转。缩放和旋转变换可以表示成3x3的矩阵，实际上所有作用于3个元素向量的线性变换，都能这么表示。

不过，这个大小的矩阵通常还不够大。一个作用于三个元素向量的函数，如$f(x) = x + (7,3,2)$就不是线性的。对两个单独的向量都进行这个变换会给每个向量都加上`(7,3,2)`。给向量加上一个固定向量也是一个变换，它可以把所有位置都移动相同的偏移位置。这是一种很有用的变换，我们可能会想要把多个变换组合起来，比如缩放一个对象到一半大小，再移动另一个位置。但如果还是用原来的函数形式，就很难将他们组合起来。

仿射变换(`affine transform`)可以组合线性变换和位移变换，一般使用4x4的矩阵来存储。一个仿射变换表示先进行一个线性变换，然后一个位移操作。我们使用齐次坐标来表示4个元素的向量，统一表示点和向量（使用小写粗体字母）。向量表示成$v = (v_x\ v_y \ v_z\ 0)^T$，点则表示为$v = (v_x\ v_y\ v_z\ 1)^T$。本周会大量使用附录A中介绍的各种术语。你可能现在就想看看附录，特别是附录A.4,关于齐次表示的章节。

所有的平移、旋转、缩放、反射以及错切矩阵都是仿射变换。仿射矩阵的主要特性是能保持线条的平行性，长度和角度就说不准了。一个仿射变换可以是其他任意数量仿射变换的组合。

本章会从最基本的仿射变换开始。这部分非常基础，甚至可以当做是简单变换的说明文档。后面会讨论和描述一些特别的矩阵，以及四元数，四元数是一个非常强大的变换工具。然后是顶点混合和变形，这两个是网格动画的简单而有效的操作方式。最后，我们会讲解投影矩阵。这些矩阵、符号、函数以及属性都可以在表格4.1中看到

![图](/images/RTR3.04.01t.png)


### 4.1 基础变换
本节描述大部分基础变换，包括平移、旋转、缩放、错切，以及变换组合，刚体变换，法线变换（这个可不`normal` :)，以及逆的计算。对于有经验的读者，这部分可以作为帮助文档，对于初学者，这部分可以作为入门介绍。这部分是非常必要的基础知识，不仅是这章后面的基础，也是本书其他后续章节的基础。我们从最最简单的平移开始。



### 4.1.1 平移
平移矩阵把一个位置变换到另一个位置，是用T来表示。这个矩阵使用向量$t=(t_x\ t_y\ t_z)$来位移对象。 T 的表示如下：

$$
T(t) = T(t_x, t_y, t_z) = 
\begin{pmatrix} 
1 & 0 & 0 & t_x \\ 
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \end{pmatrix}  \tag{4.2}
$$

![图](/images/RTR3.04.01.png)
图4.1

图4.1展示了平移变换的效果。我们可以很明显的看到（你得会矩阵相乘的规则），对于点$p = (p_x, p_y, p_y, 1)$使用T(t)变换后得到新点$p^{\prime} = (p_x + t_x, p_y + t_y, p_z + t_z, 1)$，这是一个明显的平移。注意，向量$v = (v_x, v_y, v_z, 0)$使用T来操作就没有任何效果，因为向量没法被平移。除此之外，其他所有的仿射变换都可以同时作用在点和向量上。平移矩阵的逆是负的t，$T^{-1}(t) = T(-t)$


### 4.1.2 旋转
旋转变换是给定一个角度、一个穿过原点的坐标轴，来旋转一个向量（点和向量）。跟平移一样，这也是一个刚体变换，就是说变换后，点和点之间的距离不会发生变化，左右顺序也不会变化（绝不会导致左右颠倒）。这两个变换在计算机图形对于物体的定位和朝向非常有用。一个朝向矩阵就是相机视图关联的旋转矩阵，或对象在空间中朝向的定义，也就是向上或前的方向。通常使用的旋转矩阵表示为 $R_x(\theta),R_y(\theta),R_z(\theta)$，表示相对xyz轴旋转$\theta$弧度。他们的矩阵表示如下

$$
R_x(\theta) = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & cos\theta & -sin\theta & 0 \\
0 & sin\theta & cos\theta & 0 \\
0 & 0 & 0 & 1  \end{pmatrix}  \tag{4.3}
$$

$$
R_y(\theta) = \begin{pmatrix}
cos\theta & 0 & sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-sin\theta & 0 & cos\theta & 0 \\
0 & 0 & 0 & 1  \end{pmatrix}  \tag{4.4}
$$

$$
R_z(\theta) = \begin{pmatrix}
cos\theta & -sin\theta & 0 & 0 \\
sin\theta & cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1  \end{pmatrix}  \tag{4.5}
$$

对于每个3x3的旋转矩阵R(矩阵左上的3x3范围），绕任意轴旋转角度$\theta$，它的迹（定义见附录A）与轴无关，计算如下：

$$
tr(R) = 1 + 2cos\theta. \tag{4.6}
$$

![图](/images/RTR3.04.04.png)
图4.4

图4.4展示了旋转矩阵的作用效果。旋转矩阵$R_i(\theta)$的主要特征是，它绕i轴旋转，`他是在i轴上的所有点，都没有任何变化`。有时会用R表示绕任意轴旋转的矩阵。上面给出的旋转矩阵组合，可以表现任意轴（非xyz轴）的旋转。这个步骤会在4.2.1中进一步讨论。而绕任意轴旋转的表现则在4.2.4中。

所有的旋转矩阵的每一行都是单位向量，并且互相是正交的，附录A中给出了正交矩阵的定义，我们在这里也很容易验证这一点。任意串联多个此类矩阵都还是保持这个特性。它有另一种方法来求他的逆：$R_i^{-1}(\theta) = R_i(-\theta)$，也就是绕同一个轴反方向旋转同样的角度。同样这个逆矩阵的每一行也都是单位向量，因为矩阵是正交的。

![图](/images/RTR3.04.02.png)
图4.2

举例：绕指定点旋转。假设我们想把对象绕Z轴旋转角度$\theta$，旋转中心点为给定点P。这个转换是什么样的呢？图4.2描述了这个操作过程。依据前面提的事实，旋转轴上的点都不会发生变换，我们首先进行平移，将P点对准原点，即T(-p)。然后进行旋转$R_z(\theta)$。最后再把对象平移会原来的位置，即T(p)。所以结果变换X如下：

$$
X = T(p)R_z(\theta)T(-p). \tag{4.7}
$$


### 4.1.3 缩放
缩放矩阵，$S(s) = S(s_x, s_y, s_z)$，对实体的各轴使用分别使用因子$s_x,s_y,s_z$来缩放。这意味着缩放矩阵可以放大或者缩小一个对象。$s_i, i \in {x, y, z}$越大，对象在对应方向上也就越大。把S的某元素设置为1，则表示在该方向上不缩放。S表示如下：

$$
S(s) = \begin{pmatrix}
s_x & 0 & 0 & 0\\
0 & s_y & 0 & 0\\
0 & 0 & s_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}  \tag{4.8}
$$

图4.4中展示了缩放的效果。如果$s_x = s_y = s_z$，则称缩放为`统一缩放(uniform scale)`，否则就称为非统一缩放。有时候使用术语`各向同性(isotrpic)`或`各向异性(anisotropic)`来表示这个特点。S的逆是$S^{-1}(s)=s(1/s_x, 1/s_y, 1/s_z)。$

在齐次坐标下，有另一种构建统一缩放矩阵的有效方法，就是操作矩阵下标(3,3)的元素，也就最右下角的元素。这个元素会作用齐次坐标中的w分量，也就缩放了整个坐标。比如说，统一缩放系数为5，下标为(0,0),(1,1),(2,2)的元素可以被设置为5，或者(3,3)的元素设置为1/5。两个矩阵表现如下：

$$
S = \begin{pmatrix}
5 & 0 & 0 & 0\\
0 & 5 & 0 & 0\\
0 & 0 & 5 & 0\\
0 & 0 & 0 & 1
\end{pmatrix} , \qquad
S^{\prime} = \begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1/5
\end{pmatrix}.  \tag{4.9}
$$

作为对比，S可以通用的统一缩放，而$S^{\prime}$只能在齐次坐标中使用。区分是不是齐次坐标，是很低效的。如果最右下角的元素是1，也没有区分的必要。当然了，如果整个系统总是在最右下元素为1的情况下不检测，也就没有什么额外的消耗了。

旋转矩阵的一个或三个元素为负值，则它就是一个`反射矩阵`，也叫镜像矩阵。如果两个元素为-1的话，则是旋转180度了。反射矩阵通常需要做特殊处理。举个例子，一个三角形的顶点是逆时针顺序，经过反射矩阵则会变成顺时针方向。这个顺序变化会引起不正确的光照和背部剔除问题。为了检测一个矩阵是否有某种方式的反射，我们检测左上角3x3元素的行列式的正负值，如果值是负的，则矩阵就是反射的。

举例：特定方向的缩放。缩放矩阵S在xyz轴上进行缩放。如果要在其他方向上进行缩放，则需要组合一个混合的矩阵。假设缩放要在一组右手坐标系下的正交向量$f_x, f_y, f_z$上缩放。首先构建矩阵F如下：

$$
F = \begin{pmatrix}
f_x & f_y & f_z & 0 \\
0 & 0 & 0 & 1 \end{pmatrix}.  \tag{4.10}
$$

思路是把由这三个轴构建的坐标系，旋转回标准坐标系，然后进行标准旋转，再把它旋转回去。第一步，使用F的转置，也就是F的逆。然后进行实际的旋转，最后再变换回去。整个过程如下：

$$
X = FS(s)F^T.  \tag{4.11}
$$

(译注：该例其实给定局部坐标系，对世界坐标的旋转变换，首先将目标变换到局部坐标系，然后旋转，在变换会世界坐标系。$F^T$就是世界坐标到局部坐标的转换矩阵。)

### 4.1.4 错切
另一类变换是错切矩阵。举例来说，他们能够在游戏中对整个场景进行扰动，生成一些迷幻的效果或者，或者抖动以生成模糊反射（详见9.3.1）。有6种基本的错切矩阵，记做 $H_{xy}(s), H_{xz}(s), H_{yx}(s), H_{yz}(s), H_{zx}(s), H_{zy}(s)$。第一个下标用来标记错切矩阵会变化的坐标，第二个下标则是该矩阵引起错切效果的坐标。等式4.12展示了错切矩阵$H_{xz}(s)$的例子。注意，下标可以用来寻找s参数在矩阵中的位置，x表示第0行，z则表示第2列，我们可以看到s就在那儿。

$$
H_{xz}(s) = \begin{pmatrix}
1 & 0 & s & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.12}
$$

这个矩阵作用到点p上后，依然是个点：$(p_x + sp_z, p_y, p_z)^T$。图4.3展示了单位矩形的效果。

![图](/images/RTR3.04.03.png)
图4.3

$H_{ij}(s)$(使用坐标的j元素来错切i坐标元素，并且$i \neq j$)的逆就是反向错切：$H_{ij}^{-1}(s) = H_{ij}(-s)$。

有些图形学中使用稍微变形的错切矩阵：

$$
H_{xy}^{\prime}(s,t) = \begin{pmatrix}
1 & 0 & s & 0\\
0 & 1 & t & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.13}
$$

这个矩阵中，两个下标都是表示使用第三个坐标来错切。这两种不同错切的联系可以表述成这样：$H_{ij}^{\prime}(s,t)=H_{ik}(s)H_{jk}(t)$，其中k就是第三个坐标。右边的矩阵要看API是否支持了。

最后需要注意的是，因为任何错切H的行列式值为1，它是个不改变大小体积的变换。


### 4.1.5 变换的串联
由于矩阵操作的不可交换性，矩阵串联的顺序会产生影响。变换的串联对顺序是有依赖的。

举个例子来说明顺序的依赖。设想两个矩阵S和R。S(2, 0.5, 1)对x坐标放大两倍，y坐标缩小一倍。$R(\pi / 6)$绕着z轴，顺时针方向旋转$\pi / 6$弧度。着两个矩阵的串联有两种方式，结果也完全不同。图4.4中显示两种不同的结果。

![图](/images/RTR3.04.04.png)
图4.4

把矩阵串联到一起合并成一个，最显然的原因是提高效率。举个例子，假设你有一个物体，这个物体有好几千的顶点，然后这个物体需要先被缩放、旋转然后再平移。现在，不需要对每个顶点依次进行三个矩阵变换，因为这三个矩阵已经变成了一个。只需要对每个顶点应用这一个矩阵。这个复合矩阵就是$C = TRS$。注意这里的顺序，缩放矩阵S需要首先被作用，所以它出现在表达式的最右边。这个顺序可以这么来理解$TRSp = (T(R(Sp)))$，p为目标点。（<font color="DarkGoldenRod">注：在图形学中还有另一种可行的表达方式，把平移存储在最4行而不是第4列。这种方式下，矩阵的顺序就是反的，是从左到右的。这种方式下的向量和矩阵被称作“行优先”，向量都是行向量了。在本书中，我们使用列优先方式</font>）

值得注意的是，尽管矩阵的连接有顺序依赖，但我们可以按自己的需求给他们分组。比方说前面的$TRSp$，如果你想把刚体运动的变换一次计算完成，那么可以把TR组合在一起，如$(TR)(Sp)$。矩阵的连接符合`结合律`。

### 4.1.6 刚体变换
当一个人拿到一个固体，比方说钢笔，从桌子上把它移动到其他位置，比如他的的口袋中，这个物体仅仅发生了位置和方向的变化，物体的外形没有受到任何影响。这种变换，只串联平移和旋转操作，就称为刚体变换，这个变换的特点就是，对象的长度、角度、左右关系不会发生变换。

任意一个刚体变换矩阵X，都可以被写成平移T(t)和旋转矩阵R的连接。因此，X的矩阵形式如下：

$$
X = T(t)R = \begin{pmatrix}
r_{00} & r_{01} & r_{02} & t_x\\
r_{10} & r_{11} & r_{12} & t_y\\
r_{20} & r_{21} & r_{22} & t_z\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.14}
$$

X的逆的计算如下：$X^{-1} = (T(t)R)^{-1} = R^{-1}T(t)^{-1} = R^TT(-t)$。因此，要计算该矩阵的逆，左上3x3的旋转部分转置一下，平移部分改变一下符号，得到的两个新的矩阵以相反的顺序相乘即得到X的逆。

另一个计算X的逆的方式，是把R（R作为3x3的矩阵）和X记做以下方式：

$$
\bar{R} = (r_{,0}\; r_{,1}\; r_{,2}) = \begin{pmatrix} r_{0,}^T \\ r_{1,}^T \\ r_{2,}^T \end{pmatrix}, \\
X = \begin{pmatrix} \bar{R} & t \\ 0^T & 1 \end{pmatrix}  \tag{4.15}
$$

这里，0代表的是3x1全是0的一个列向量。逆的计算可以简化成下面的样子：

$$
X^{-1} = \begin{pmatrix}
r_{0,} & r_{1,} & r_{2,} & -\bar{R}^Tt \\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.16}
$$


### 4.1.7 法线变换
同一个矩阵可以用来变换点、线、多边形和其他几何对象。同样也可以变换这些线或表面多边形的切线向量。但是，这个矩阵却不能用来变换几何对象的一个非常重要的属性，那就是表面法线（以及顶点光照法线）。图4.5展示了，如果使用同一个矩阵会发生产生什么样的结果。

![图](/images/RTR3.04.05.png)
图4.5. 最左是源对象，显示了线段和他的法线。中间显示了如果使用同一个矩阵变换对x轴缩放0.5，同时作用线段和法线的结果。右图则显示了法线应该的结果。

正确的方法是使用模型变换矩阵的`伴随矩阵的转置`来操作法线。伴随矩阵的计算见附录A.3.1。伴随矩阵永远都是存在的。法线在变换后无法保证还是单位向量，所以一般需要重新规范化。

传统的变换法线的方法是，计算模型变换矩阵逆的转置。这个方法一般情况下可行。不需要计算完整的逆矩阵，而且有时无法找到逆矩阵。逆矩阵就是伴随矩阵除以源矩阵的行列式。如果行列式为0，则表示源矩阵是奇异的，这时逆矩阵并不存在。

即使仅仅计算4x4的伴随矩阵也是很费时的，通常也没有必要。因为发现是一个向量，平移并不会对它产生效果。此外，大部分模型变换都是仿射变换。他们不会改变齐次坐标的w分量，就是说不会进行投影。有了这些前提，我们只需要计算左上角3x3的部分的伴随矩阵，来做法线变换就可以了。

伴随矩阵很多时候也不需要计算。如果我们知道模型变换矩阵完全是由平移、旋转以及统一缩放操作串联起来的（没有拉伸或挤压）。平移不会影响法线，统一缩放只改变法线的长度。所以剩下的就只有旋转，而旋转只是旋转，没什么其他的。而且旋转矩阵的逆就等于它的转置。它的逆的转置可以用来做法线变换，两次转置就相互抵消了($(R^{-1})^T = (R^T)^T = R$)。综上，在这种情况下，可以直接使用模型变换取变换法线。

最后，重新对法线规范化的操作也不是永远需要的。如果只是平移和旋转操作的连接，那么法线在变换后长度并不会发生变化，所以也就不用规范化。如果使用了统一缩放操作，如果知道统一缩放的系数的话，那么也可以直接用来规范化法线。比方说，如果我们知道所有的缩放就是把物体放大5.2倍，那么法线变换后，除以5.2就规范化好了。另外，我们可以创建一个使得法线变换结果是规范化的法线变换矩阵，就是使用源矩阵左上3x3部分直接除以统一缩放系数。

注意法线的变换并不是个问题，在变换之后，表面法线可以通过三角形的边推导（叉乘）出来。切线天然就跟法线不一样，它总是可以直接用模型变换来变换。


### 4.1.8 逆的计算
逆在很多情况下都需要计算，比方说坐标系来回转换。基于变换的情况，可以使用以下三种方法来计算逆。

 * 如果矩阵是单个变换，或者是给点参数的多个简单变换序列，那么逆的计算很容易，使用相反的从参数，相反的顺序即可。比方说：$M = T(t)R(\theta), 则 M^{-1} = R(-\theta)T(-t)$
 * 如果矩阵是正交的，则 $M = M^{-1}$，也就是说转置就是逆。任意旋转的序列组合还是个旋转，且是正交的。
 * 如果矩阵没有特点，那么附录A.38中介绍的伴随矩阵计算方法，克莱姆法则，LU分解，高斯消元法等可以用来计算逆矩阵（见附录A.3.1)。克莱姆法则跟伴随矩阵方法更好一点，因为他们的分支比较少。现代GPU架构上要尽量避免使用if分支。4.1.7已经提到如何使用伴随矩阵进行法线变换。

在优化的时候，计算逆矩阵的目的也需要考量。比如说，如果逆矩阵是要用来变换向量，那么则只需要计算矩阵左上3x3的部分。


