---
title: "投影"
sidebar: rtr
layout: book
permalink: rtr_ch4_proj.html
summary: 第四章.
---

### 4.6 投影
在你渲染场景之前，场景里所有相关的对象需要投影到某种平面上，或者一个简单的立方体里面。然后裁剪和渲染才能进行（见章节2.3）

我们目前见到的变换都没有使用到第四个分量(w)。这是因为，点和向量在变换后依然是点和向量。4x4矩阵的最底下一行也一直是(0 0 0 1)。`透视投影矩阵`会改变这两个特点：底部的行中包含了点和向量的操作数，所以需要做齐次化操作（也就是，w不是1，所以必须除以w，以得到非齐次的点）。我们会在先介绍`正交投影(Orthographic projection)`，这是一个非常简单的但也使用频繁的投影，它不需要使用w分量。

在这节当中，我们假设观察者朝着z轴负方向观察，y轴是up向量，x轴则是right向量。这是一个右手坐标系。有些软件中，比如DX，使用的是左手坐标系，那么观察者就是看向z轴正方形。两种坐标系都是可以的，最后都会得当相同的效果。

### 4.6.1 正交投影
正交投影的特点是投影后，平行线还是平行线（即线性）。下面的矩阵$P_o$，是一个简单的正交投影矩阵，它保持xy轴不变，设置z为0，也就是垂直的投影到平面 z=0上：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1  \end{pmatrix}  \tag{4.59}
$$

这个投影的效果如图4.16。很显然，该矩阵是不可逆的，因为$\Vert P_o \Vert = 0$。换句话说，这个变化把三维降到了二维形式，目前没有任何办法恢复这个维度损失。使用这种正交矩阵的一个问题是，z值为正值得点和为负的点，都投影到投影平面上了。这在约束z值（xy也可以）到一个特定的范围，从n(近平面）到f(远平面）时会很有用。这也是下一个变形的目的。

![图](/images/RTR3.04.16.png)
图4.16

表示正交投影的一个更常见的方式是`六元组(six-tuple)(l, r, b, t, n, f)`，表示 左， 右， 下， 上， 近， 远六个面。这个矩阵缩放及平移AABB(`Axis-Aligned Bounding Box`;定义见章节16.2)，AABB由前面的六个面构成，中心是原点，与坐标轴平行。AABB最小的拐角是(l,b,n)，最大拐角是(r,t,f)。需要注意的是`n > f`，因为我们看向的是z轴负方向。我们一般的认知会觉得近平面的值应该小于远平面的值。在OpenGL中，也是看向z轴负方向，他提供正交投影矩阵的构造函数`glOrtho`，n的输入值要小于f的输入值，然后在内部把两个值取负。另一种看待OpenGL的n和f的方法是，把他们看成是到观察点的距离，而不是z坐标值。

在OpenGL中，轴对齐立方体的最小点是(-1,-1,-1)，最大点是(1,1,1)；而在DX中，最小点是(-1,-1,0)，最大点是(1,1,1)。这个立方体被称作`标准视体(canonical view volume)`，这个立方体里的坐标则被为`标准化设备坐标(normalized device coordinates)`。图4.17展示了变形处理过程。变换到标准视体的原因是裁剪会更加的统一高效。

![图](/images/RTR3.04.17.png)
图4.17

在变换到标准视体后，图元需要渲染的顶点会被这个立方体裁剪。立方体内的图元最终被映射到屏幕上。OpenGL中的正交变换矩阵如下：
<font size="4">
$$
\begin{align}
P_o = S(s)T(t) &= \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{f-n} & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}  \begin{pmatrix}
1 & 0 & 0 & -\frac{l+r}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{f+n}{2} \\
0 & 0 & 0 & 1
\end{pmatrix} \\
&= \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{l+r}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & \frac{2}{f-n} & -\frac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{pmatrix}. \tag{4.60}
\end{align}
$$
</font>

正如这个等式所示，$P_o$可以写成$T(t)与S(s)$形式，其中$s = (2/(r-l),2/(t-b),2/(f-n)), t = (-(r+l)/2,-(t+b)/2,-(f+n)/2)。这个矩阵是可逆的，即$P_o^{-1} = T(-t)S(1/s) = T(-t)S((r-l)/2,(t-b)/2,(f-n)/2)$。

在计算机图形中，投影之后一般都变成了左手坐标系——就是说，对于`视口(viewport)`，x轴是right向量，y轴是up向量，z轴朝向视口内部。由于我们定义的AABB中，far值是小于near值得，正交变换中总是有一个镜像变换。为了说明这一点，我们先设AABB的大小跟标准视体大小一样。所以AABB的坐标最小点(l,b,n)为(-1,-1,1)，(r,t,f)为(1,1,-1)。则等式4.60变为：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & -1 & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.61}
$$

这是一个镜像矩阵。也就是它把观察的右手坐标系(看下负z轴)变为左手的标准设备坐标系。

DX中z的映射范围为[0,1]，而不是OpenGL中的[-1,1]。这可以使用一个包含缩放和平移的简单矩阵来完成，在正交投影矩阵操作之后使用。这个矩阵如下：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0.5 & 0.5\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.62}
$$

所以DX中最终的正交投影矩阵为：

<font size="4">
$$
P_{o[0,1]} = \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{l+r}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & \frac{1}{f-n} & -\frac{n}{f-n} \\
0 & 0 & 0 & 1
\end{pmatrix}. \tag{4.60}
$$
</font>

而且这个矩阵一般要使用它的转置形式，因为DX中矩阵是行优先的形式。


### 4.6.2 投影投影
透视投影比正交投影要有趣的多，也是计算机图形应用主要使用的投影方式。透视投影之后，平行线基本不会再保持平行，极端情况下可能会变成一个点。透视投影更接近我们对世界的感知，就是远的东西会比较小。


![图](/images/RTR3.04.18.png)
图4.18

首先，我们来推导投影到平面$z = -d, d > 0$上的透视投影矩阵，这对后面的计算会很有用。我们从世界空间开始推导，这有助于理解如何从世界空间转变到视图空间。推导过程使用的都是一些常用的矩阵。

假设相机（观察点）位于原点，我们投影点p到平面$z = -d, d > 0$，得到一个新点$q = (q_x, q_y, -d)$。图4.18展示这个假设。根据图上的相似三角形，我们得到以下等式：

$$
\frac{q_x}{p_x} = \frac{-d}{p_x}   \qquad \Longleftrightarrow \qquad q_x = -d\frac{p_x}{p_z}.   \tag{4.64}
$$

类似x分量，y分量的计算为$q_y = -dp_y/p_z, 而q_z = -d$。根据上面的公式，我们可以得到透视投影矩阵$P_p$:

$$
P_p = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 &1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & -1/d & 0
\end{pmatrix}. \tag{4.65}
$$

我们可以用下面的等式来验证矩阵是否正确：

$$
q = P_pp = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 &1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & -1/d & 0
\end{pmatrix} \begin{pmatrix} p_x \\ p_y \\ p_x \\ 1 \end{pmatrix}
= \begin{pmatrix} p_x \\ p_y \\ p_x \\ -p_z/d \end{pmatrix}  
\Rightarrow 
\begin{pmatrix} -dp_x/p_z \\ -dp_y/p_z \\ -d \\ 1 \end{pmatrix}. \tag{4.66}
$$

最后一步的操作，基于整个向量需要除以w分量，以得到`w=1`。结果的z值用于都是-d，因为我们就是投影到这个平面上。

直观的来说，理解使用齐次坐标来投影很好理解。有个几何上的解释是齐次操作是把点投影到w=1的平面上。

![图](/images/RTR3.04.19.png)
图4.19

既然有正交转换，透视变换也是有的，不仅仅是把对象投影到一个面上，透视变换把`观察平头截体(view frustum)`投影到标准视体中。在这里假设平头截体z轴开始于`z = n`，结束于`z = f`，且`0 > n > f`。z=n处的矩形的最小点为`(l,b,n)`，最大点为`(r,t,n)`。如图4.19所示。

参数`(l,r,b,t,n,f)`决定了相机的观察平头截体。视图的水平fov`(field of view 视场角)`由平头截体的左右平面(l和r决定)的夹角决定。同样的垂直fov由上下平面(t和b决定)的夹角决定。fov越大，相机能看到的东西就越多。可以使用$r \neq -l, or t \neq -b$来构建`非对称平头截体`。非对称平头截体可以用于洞穴内的立体视图（见章节18.1.4）。

fov是如何看到场景的一个非常重要的参数。跟屏幕相比，眼睛本身也有个物理上的fov。他们二者的关系如下：

$$
\theta = 2 arctan(w/(2d)).     \tag{4.67}
$$

其中$\theta$是fov，w是物体投影到视野上的宽度，d则是物体的距离。比方说，一个21寸的显示器是16寸宽，那么推荐的最小观看距离是25寸远，这时它在眼中的投影角度在35度左右。在12寸远的地方，fov是67度，18寸是35度，30寸则是30度。这个公式同样可以用来计算相机焦距跟fov的关系，就是说，50毫米焦距对于35毫米的相机（它的帧宽度是36）来说，可以得到$\theta = 2 arctan(36/(2 * 50)) = 39.6度$。

偏窄的fov会让透视效果变弱，因为视图会适应屏幕缩放（就是又被拉宽了，所以效果变弱了）。一个比较宽的fov则会使对象发生失真（就好比使用广角镜），特别是屏幕边缘附加的物体会被放大。尽管如此，更宽的fov让观察者看到的物体更大，更动人，也给使用者提供了周围更多的信息。

变换平头截体到单位立方体的透视投影矩阵表示如下：


$$
P_p = \begin{pmatrix}
\frac{2n}{r-l} & 0 & -\frac{l+r}{r-l} & 0 \\
0 & \frac{2n}{t-b} & -\frac{t+b}{t-b} & 0 \\
0 & 0 & \frac{f+n}{f-n} & -\frac{2fn}{f-n} \\
0 & 0 & 1 & 0
\end{pmatrix}. \tag{4.68}
$$


对一个点应用这个变换后，我们得到另一个点$q = (q_x, q_y, q_z, q_w)^T$。这个点的w分量一般来说不可为0，也不等于1。为了得到投影点p，我们需要除以$q_w: p = (q_x/q_w, q_y/q_w, q_z/q_w, 1)^T。矩阵$P_p$把z=f映射到+1，而z=n映射到-1。在透视投影之后，通过裁剪和齐次化（就是除以w）来得到`标准设备坐标`。

要得到OpenGL中的透视变换，首先要乘上矩阵$S(1,1,-1)$，跟正交投影一样的原因。这个变换把等式4.68中第三列的值反过来。在这个镜像变换之后，近值和远值都变成正值了，并且$0 < n' < f'$，这是用户比较习惯的表达方式。不过，它们表现的还是在z轴负方向上的距离，因为这是观察的朝向。我们列出公式以便参考：


$$
P_{OpenGL} = \begin{pmatrix}
\frac{2n'}{r-l} & 0 & \frac{l+r}{r-l} & 0 \\
0 & \frac{2n'}{t-b} & \frac{t+b}{t-b} & 0 \\
0 & 0 & -\frac{f'+n'}{f'-n'} & -\frac{2f'n'}{f'-n'} \\
0 & 0 & 1 & 0
\end{pmatrix}. \tag{4.69}
$$

有些API（比如DX）把近平面映射到z=0（而不是z=-1），远平面映射到z=1上。而且，DX使用的是左手坐标系来定义投影矩阵。这表示DX的相机是看向z轴正方向，n和f也表现为正值，下面是DX的表达式：

<font size="4">
$$
P_{p[0,1]} = \begin{pmatrix}
\frac{2n'}{r-l} & 0 & -\frac{l+r}{r-l} & 0 \\
0 & \frac{2n'}{t-b} & -\frac{t+b}{t-b} & 0 \\
0 & 0 & -\frac{f'}{f'-n'} & -\frac{f'n'}{f'-n'} \\
0 & 0 & 1 & 0
\end{pmatrix}. \tag{4.70}
$$ </font>

DX使用的还是行优先形式，所以这个矩阵一般都是用转置形式表现。

使用透视变换的一个效果是计算后的深度值，跟输入的$p_z$不是线性的关系。比方说，$n' = 10, f' = 110$（使用OpenGL用法），当$P_z$是-60的时候（也就是中点值），标准化后的深度值是0.833，而不是0。图4.20展示离近平面不同距离的深度值结果。不同的远近平面会影响Z缓冲的精度。这会在章节18.1.2中深入讨论。

![图](/images/RTR3.04.20.png)
图4.20

### 扩展阅读和资源
`《The Geometry Toolbox》`是一本`无痛`建立个人对矩阵感觉的最好的一本书之一。另一个是Lengyel的`《Mathematics for 3D Game Programming and Computer Graphics》[761]`。一些不同的透视在很多计算机文章中有提及，比如Hearn 和 Baker[516], Shirley[1172], Watt[1330]，以及Foley等人的两本书[348,349]。`《Graphics Gems》`系列[36,405,522,667,982]中展示了很多变化相关的算法以及很多在线的代码。Golub和Van Loan的`《Matrix Computations》`[419]可以用来认真的学习矩阵相关技术的材料。[本书的网站](http://www.realtimerendering.com)也有很多变化的代码，以及四元数。想了解更多关于骨骼空间变形、顶点融合以及形状插值的内容，可以阅读Levis等人的SIGGRAPH论文[770]。

Hart等人[507]和Hanson[498]的文章中提供了一些四元素的知识，Pletinckx[1019]和Schlag[1126]的文章中展示了一些不同的方法来对四元数组平滑插值。Vlachos和Isidoro[1305]的文章中得到四元素$C^2$插值的各种公式。四元素插值是和计算弧线上稳定坐标息息相关的，这在Dougan[276]的文章中有探讨。


Alexa[16]和Lazarus & Verroust[734]的文章中展示了很多不同的变形技术。

