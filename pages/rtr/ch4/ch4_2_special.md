---
title: "特殊变换及操作"
sidebar: rtr
layout: book
permalink: rtr_ch4_special.html
summary: 第四章.
---

### 4.2 特殊矩阵变换和操作
本节中，我们会单独介绍实时图像中非常精要的一些矩阵变换和操作。首先我们介绍欧拉变换（以及它的导出参数），这是表达方向非常直观的方式。然后我们介绍一些基础变换，最后，我们会得出一个绕任意轴旋转的方法。

### 4.2.1 欧拉变换
这个变换是构建你自己（也就是相机）朝向，或者其他任何实体的朝向，的一个非常直观的方式，这个名字来自伟大的瑞士数学家Leonhard Euler(1707-1783)。

![图](/images/RTR3.04.06.png)
图4.6

首先，我们需要创建默认的视角方向。大部分情况下它朝向Z轴负方向，且头上的方向是y轴正方向，如图4.6中所示。欧拉变换其实是操作图中标示出名字的三个矩阵。比较正式的表示如下等式（<font color="DarkGoldenRod">注，理论上存在24中不同的组合顺序，这里选了最常用的一个顺序</font>）：

$$
E(h,p,r) = R_z(r)R_x(p)R_y(h). \tag{4.17}
$$

E是旋转矩阵的串联，所以它是正交的。所以它的逆可以表示为：$E^{-1} = E^T = (R_zR_x_R_y)^T = R_y^TR_x^TR_z^T$。所以可以简单直接的使用E的转置矩阵。

欧拉角h p r表示了依赖顺序，以及`head, pitch, roll`分别绕他们的轴旋转多少度(<font color="DarkGoldenRod">注，head有时被称为yaw。这些角也被称为'rolls'，比如pitch是x-roll等</font>)。这种变换很直观，也很容易以外行的语言来讨论。比方说，改变head的角度，就是让观察者摇头，改变pitch的角度则是点头，roll则是左右摇摆他的头。我们不说绕xyz轴旋转，而使用head,pitch和roll。注意这个变换不仅可以用于相机，也可以用于其他任意实体。该变换可以使用世界坐标轴来变换，也可以用局部坐标轴。


当我们使用欧拉变换的时候，可能会发生一种`万向锁(gimbbal lock)`的情况。这种情况发生于旋转导致一个自由度的丢失。比方说，在变换顺序x/y/z下，如果以$\pi / 2$角度绕y轴旋转，旋转之后的局部坐标系的z轴，和世界坐标系的x轴就重合了，以致于最后的z轴旋转显的有点多余。

这里有另一个方法来观察自由度丢失的问题，在欧拉矩阵$E(h,p,r)$中，假设$p = \pi / 2$，看看会发生什么？

$$
E(h, \pi/2, r) = \begin{pmatrix}
cos(r)cos(h) - sin(r)sin(h) & 0 & cos(r)sin(h) + sin(r)cos(h) \\
sin(r)cos(h) - cos(r)sin(h) & 0 & sin(r)sin(h) + cos(r)cos(h) \\
0 & 1 & 0
\end{pmatrix} \\
= \begin{pmatrix}
cos(r + h) & 0 & sin(r + h) \\
sin(r + h) & 0 & -cos(r + h) \\
0 & 1 & 0
\end{pmatrix}. \tag{4.18}
$$

我们可以看到最终的结果，只取决(r+h)的和，所以我们认为有一个自由度丢失了。

现代系统中，欧拉角通常是使用x/y/z的变换顺序，不过其实，按其他顺序绕局部坐标轴旋转的方式也是可以的。比方说，z/x/y就常在动画中使用，z/x/z可以在动画和物理中使用。这些都是指定三个独立旋转矩阵的合法方法。其中z/x/z，在一些程序中表现比较好，且只用当绕x轴180度的时候才会引起`万向锁`。根据`毛球理论(hairy ball theorem)`，万向锁没法完全避免的，没有一种完美的序列可以避免它。

欧拉角在小角度变换和视角变换中非常有用，但是它也有一些限制。处理两个不同的欧拉角组合就很困难。比方说，两个欧拉角的插值，就不是简单的对每个旋转角插值。实际上，两个不同的欧拉角组合，可以对应的是同一个结果，所以这两个组合的插值实际不会旋转对象。这些问题是其他一些方向描述使用的原因，比如本章后面要讲的四元数，值得期待。

### 4.2.2 欧拉变换的参数推导
在某些情况下，从正交矩阵中，推导出欧拉变换的hpr参数是很有用的。等式4.19展示了推导步骤

$$
F = \begin{pmatrix}
f_{00} & f_{01} & f_{02} \\
f_{10} & f_{11} & f_{12} \\
f_{20} & f_{21} & f_{22} 
\end{pmatrix} = R_z(r)R_x(p)R_y(h)= E(h,p,r). \tag{4.19}
$$

连接4.19中三个旋转矩阵可得：

$$
F = \begin{pmatrix}
cos(r)cos(h) - sin(r)sin(p)sin(h) & -sin(r)cos(p) & cos(r)sin(h) + sin(r)sin(p)cos(h) \\
sin(r)cos(h) - cos(r)sin(p)sin(h) & -cos(r)cos(p) & sin(r)sin(h) + cos(r)sin(p)cos(h) \\
cos(p)sin(h) & sin(p) & cos(p)cos(h)
\end{pmatrix}. \tag{4.20}
$$

所以我们知道pitch通过$sin(p) = f_{21}$来得到。通过$f_{01}除以f_{11}$以及$f_{20}除以f_{22}$可以得到head和roll的参数：

$$
\frac{f_{01}}{f_{11}} = \frac{-sin(r)}{cos{r}} = - tan(r), \\
\frac{f_{20}}{f_{22}} = \frac{-sin(h)}{cos{h}} = - tan(h).  \tag{4.21}
$$

因此，欧拉角的参数hpr可以使用矩阵F的元素来带入函数`atan2(y, x)`来求得，如下表达式：

$$
h = atan2(-f_{20},f_{22}),\\
p = arcsin(f_{21}),\\
r = atan2(-f_{01},f_{11}).  \tag{4.22}
$$

不过，我们需要处理一种特殊情况。当$cos(p)=0$的时候，则$f_{01} = f_{11} = 0$，也就不能使用atan2函数了。$cos(p)=0时，sin(p) = \pm 1$，所以F可以简化成如下形式：

$$
F = \begin{pmatrix}
cos(r \pm h) & 0 & sin(r \pm h) \\
sin(r \pm h) & 0 & -cos(r \pm h) \\
0 & \pm 1 & 0
\end{pmatrix}. \tag{4.23}
$$

对于其他的参数的计算，我们可以假设h = 0，则$sin(r)/cos(r) = tan(r) = f_{10}/f_{00}，于是r = atan2(f_{10},f_{00})$。(<font color="DarkGoldenRod">注，这里有了$sin(r)=f_{10}$，为什么还要求tan? 因为arcsin的取值范围吗？</font>)

注意，从arcsin的定义（见章节B.1)我们知道，$-\pi / 2 \le p \le \pi/2$，这表示矩阵F是通过一个超出此范围的p来构建的，则原始的p是没法还原的。hpr不唯一意味着同一个矩阵可以分解成多种不同的参数。Shoemake's 1994 文章中有更多关于欧拉角的转换。上面提到的方法简单有效，却有一些数值稳定问题，不过这可以避免一些速度的消耗。

举例：约束变换。想象你正拿着一个扳手拧螺丝，为了拧紧螺丝，你需要把扳手绕着x轴旋转。现在假设你的输入设备（鼠标什么的）传输给你一个正交矩阵用来操作扳手的运动。你可能会遇到的问题是，你不能直接把这个矩阵变换应用于扳手，因为扳手必须绕x轴旋转。所以为了把输入矩阵P，约束到只在x轴上旋转，我们就可以使用前面使用的方法来导出hpr三个参数，并构建一个新的矩阵$R_x(p)$。这个就是我们需要的旋转矩阵了（如果P中包含这个旋转的话）。

### 4.2.3 矩阵分解
到目前为止，我们处理的矩阵都处在这种假设之下：我们知道我们使用的原始矩阵所有信息。很多时候并非如此，比如我们可能只有一个用于变换对象的`串联后的结果矩阵`。从串联矩阵重新计算出多个变换的过程就叫做`矩阵分解`。

为什么要做矩阵分解呢？这有一些原因：

* 推导对象的缩放系数。
* 找寻粒子系统需要的变换。比方说VRML使用一个变换的节点，但却不能使用任意的4x4矩阵来变换。
* 确定一个对象是否被作用了一个刚体变换。
* 动画关键帧插值，找到可用于插值的矩阵。
* 在旋转矩阵中去除错切变换。

我们前面已经介绍过两种分解方式，4.1.6介绍了从刚体变换中分离平移和旋转矩阵，4.2.2介绍了如何从正交矩阵中分离欧拉角参数。

平移矩阵的获取比较简单，我们只需要把4x4矩阵的第四列拿出来就行了。我们也能通过检测矩阵的行列式的值的正负，来判定矩阵是否存在反射操作。要分离旋转、缩放和错切则需要更多工作。

好在这方面已经有很多文献材料，网上也有可用的代码。Thomas[1265]和Goldman[414,415]都提供了不同类型变换的不同方法。Shoemake[1178]则发展仿射矩阵相关的技术，他的算法不同于其他的框架，他尝试通过分解矩阵来得到刚体变换。

### 4.2.4 任意轴旋转
有时候，我们可能需要把实体绕着任意轴旋转。假设一个已规范化的旋转轴是r，我们需要创建一个绕它旋转$\alpha$角度的旋转矩阵。

为了做到这点，我们首先要找到另外两个单位向量，他们跟r构成一个基础的正交的坐标系。计算的思路是把这个新的坐标系旋转到跟标准坐标系对齐(详见A.3.2)，然后旋转指定角度，再转回新到的坐标系。过程如下：

![图](/images/RTR3.04.07.png)
图4.7

第一步是要计算正交基。第一个轴是r，也就是我们要绕着旋转的轴。现在我们来看如何寻找第二个轴s，我们知道第三个轴t等于前两个轴的叉乘，$t = r x s$。有个数学上的方法来找到r的最小的元素(绝对值)，并设置为0。然后交换其余两个元素，再把第一个设负值。数学上的表达如下：

$$
\bar s = \begin{cases}
(0,-r_z,r_y), & if |r_x| \lt |r_y| and |r_x| \lt |r_z|, \\
(-r_z,0,r_x), & if |r_y| \lt |r_x| and |r_y| \lt |r_z|, \\
(-r_y,r_x,0), & if |r_z| \lt |r_x| and |r_z| \lt |r_y|,  
\end{cases} \\

s = \bar s / \Vert{\bar s}\Vert, \\
t = r \times s.  \tag{4.24}
$$

因为$\bar s$与r肯定是垂直，并且$(r, s, t)$是一对正交基。我们用这三个向量行来表示矩阵：

$$
M = \begin{pmatrix}
r_T \\ s_T \\ t_T
\end{pmatrix}. \tag{4.25}
$$

这个矩阵可以把向量$\vec r$对齐到标准x轴上，s对齐到y轴上，而t则对齐到z轴上。所以绕r旋转角度的最终表达式为：

$$
X = M_TR_x(\alpha)M.  \tag(4.26)
$$

也就是说，首先我们通过M把r变换到x轴上，然后使用$R_x(\alpha)$旋转指定角度，再使用M的逆矩阵变换回去，在这里就是$M_T$，因为M是正交矩阵，$M^T = M^{-1}$。

另一个绕任意轴旋转的方法是，Goldman[412]提供的使用$\theta$规范化轴r方法。这里我们仅给出它的变换矩阵：

$$
R = \begin{pmatrix}
cos(\theta) + (1 - cos(\theta))r_x^2 & (1 - cos(\theta))r_xr_y - r_zsin(\theta) & (1 - cos(\theta))r_xr_z + r_ysin(\theta) \\ 
(1 - cos(\theta))r_xr_y + r_zsin(\theta) & cos(\theta) + (1 - cos(\theta))r_y^2 & (1 - cos(\theta))r_yr_z - r_xsin(\theta) \\ 
(1 - cos(\theta))r_xr_z - r_ysin(\theta) & (1 - cos(\theta))r_yr_z - r_xsin(\theta) & cos(\theta) + (1 - cos(\theta))r_z^2  \end{pmatrix}. \tag{4.27}
$$

在4.3.2中，我们会探讨解决这个问题的另一种方法，就是使用四元素。同样也会探讨旋转相关更高效的算法，比如旋转向量。


