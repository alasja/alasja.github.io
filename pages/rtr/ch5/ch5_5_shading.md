---
title: "5.5 着色器"
sidebar: rtr
layout: book
permalink: rtr_ch5_shading.html
---

### 5.5 着色器
着色是使用一个公式，依据材质属性和光源，来计算视线v方向上的输出辐射度$L_0$。第七章会探讨很多可行的着色公式。这里我们使用一个相对简单的例子来作为说明，并说明如何使用在可编程着色器中实现它。

我们使用的公式中包括漫反射和高光部分。漫反射部分很简单。根据上一节中的定义，我们可以得到漫反射出射度$M_{diff}$是光线辐照度$E_L$，它的方向*l*和漫反射颜色的函数：

$$
M_{diff} = c_{diff} \bigotimes E_L \overline{cos} \theta_i.    \tag{5.3}
$$

这里$\bigotimes$表示对向量按位乘（这里都是RGB向量）。

因为我们假定漫反射在各个方向上的辐射度$L_{diff}$都是一样，于是得到以下关系式（7.5.1会详细解释原因）：

$$
L_{diff} = \frac{M_{diff}}{\pi}. \tag{5.4}
$$

将公式5.3，5.4连起来，我们可以得到：

$$
L_{diff} = \frac{c_{diff}}{\pi} \bigotimes E_L \overline{cos} \theta_i. \tag{5.5}
$$

这种漫反射着色方式也被称为`Lambertian`， 它遵从`兰伯特定律(Lambert's law)`，这个定律定义了理想漫反射表面输出的辐射率跟$\overline{cos}\theta_i$成正比。注意，这个限制范围的余弦因子（一般使用法线*n*与光线*l*点乘得到，使用max(n·l,0）并不是兰伯特表面特有的；正如我们看到的，它一般使用在辐照度上。兰伯特表面的特点是输出的辐射率正比与辐照度。只要你看过兰伯特的着色代码，就会发现除了$1/\pi$跟等式5.5很相像。这个因子在实时渲染中一般已经包含在$E_L$中了。（7.5节会深入相关细节）

类似公式5.3，高光的等式如下：

$$
M_{spec} = c_{spec} \bigotimes E_L \overline{cos} \theta_i.    \tag{5.6}
$$

高光项比漫反射要复杂一些，因为它对方向的依赖。在这里，我们使用`半程向量(half vector)h`，之所以这么叫是因为它是视线向量*v*和光线向量*l*的中值。计算方法如下：

$$
h = \frac{l + v}{\Vert l + v \Vert}.        \tag{5.7}
$$

使用*l+v*除以他们的长度，得到单位向量。

下面的等式用来定义高光辐射度$L_{spec}$的分布情况（7.6节会解释为什么会是这样）：

$$
L_{spec}(v) = \frac{m + 8}{8 \pi} \overline{cos}^m \theta_h M_{spec}.   \tag{5.8}
$$

其中$\theta_h$是*h* 和 *n* 之间的夹角，见图5.13 。

![图](/images/RTR3.05.13.png)
图5.13

需要注意的是，与$L_{diff}不同，L_{spec}$取决于视线向量*v*（非直接的，实际是取决于向量*h*)。$L_{spec}$随着向量*h，v*的夹角减小而增大。变化的速度则由参数*m*决定，它代表表面的光泽度。增大*m*会使得高光更小、更亮。结合等式5.6和5.8得到高光项的着色计算公式：

$$
L_{spec}(v) = \frac{m + 8}{8 \pi} \overline{cos}^m \theta_h c_{spec} \bigotimes E_L \overline{cos} \theta_i.   \tag{5.9}
$$

由上面可得，完整的计算这两项的着色公式是：

$$
L_o(v) = \left( \frac{c_{diff}}{\pi} + \frac{m + 8}{8 \pi} \overline{cos}^m \theta_h c_{spec} \right) \bigotimes E_L \overline{cos} \theta_i.   \tag{5.10}
$$

这个着色等式跟`Blinn-Phong`着色很相似，它是由Blinn在1977年的文章中首次提出：
（<font color="DarkGoldenRod">注：Blinn的论文实际上说的是一个完全不同着色公式，`Blinn-Phong`等式只是在提及之前工作（Phong前两年发表的多个着色公式）的部分，简略的提了一下。但是神奇的是，这个`Blinn-Phong`公式迅速的被大家所接受，以至于他的论文的主要内容都被忽略了，直到四年后`Cook-Torrance`论文才重见天日 </font>）

$$
L_o(v) = \left( \overline{cos} \theta_i c_{diff} + \overline{cos}^m \theta_h c_{spec} \right) \bigotimes B_L.  \tag{5.11}
$$

这里使用$B_L$而不是$E_L$由一些历史原因，这个公式不常用在物理光照中，它会有一种把光源增亮的效果。不过这个公式出现的地方没有处理任何关于光强度的问题。如果我们令$B_L = E_L/\pi$，则它跟5.10就更加相像了，只有两个不同：少了$(m + 8)/8$项，以及高光项没有乘上$\overline{cos}\theta_i$。第七章会更详细的介绍这些不同之处。


### 5.5.1 着色公式实现
5.10这类等式一般在顶点着色器或像素着色器中求值。本章会实现这个等式的一个简化版本，即整个网格的材质属性($c_{diff}, c_{spec}和m$)都是固定的。第六章会讨论一些特别的材质属性使用方式。

等式5.10只计算了单个光源。不过，场景经常会包含多个光源。光线自然而然需要叠加，所以我们可以叠加各个光源的贡献，以得到整体的着色公式：

$$
L_o(v) = \sum_{k=1}^n \left( \left( \frac{c_{diff}}{\pi} + \frac{m + 8}{8 \pi} \overline{cos}^m \theta_{h_k} c_{spec} \right) \bigotimes E_{L_k} \overline{cos} \theta_{i_k} \right). \tag{5.12}
$$

其中$\theta_{h_k}$表示第k个光源的$\theta_h$。

7.9节会讨论多光源的一些问题和相关实现选项。这里我们使用着色器的动态分支功能来遍历这些光源，这是个简单但并不最优的方法。

设计一个着色器实现的时候，需要按照求值的频率把计算划分开。频率最低的是`逐模型求值`：对整个模型来说，这个值都是固定的，所以只需要程序求值一次，并将结果传递给图像API。如果模型上的每个图元，需要求的某个值是一样的，那么就可以`逐图元求值`。逐图元计算是在几何着色器中完成，计算结果会传递给图元的每个像素。`逐顶点求值`的计算是在顶点着色器中完成的，这些结果会针对整个三角形线性插值，并传递给像素着色器。最后，频率最高的就是`逐像素求值`，它在像素着色器中计算完成（这些着色阶段我们都在3.1节中介绍过了）
(<font color="DarkGoldenRod">注：逐图元计算也可以在顶点着色器中完成，如果他们不需要图元的相关信息的话。通过在三角形的第一个顶点上操作图元的属性（比如三角形的法线），并禁止插值，来做到这一点。禁止插值就可以让第一个顶点上值传递给该图元所有的像素。 </font>)

5.12公式该为逐模型计算后：

$$
L_o(v) = \sum_{k=1}^n \left( \left( K_d + K_s \overline{cos}^m \theta_{h_k} \right) \bigotimes E_{L_k} \overline{cos} \theta_{i_k} \right). \tag{5.13}
$$

其中$K_d = c_{diff}/\pi , K_s = ((m + 8) / 8\pi)c_{spec}$，这部分由cpu计算完成。因为我们只使用方向光，$l_k和E_{L_k}$也是不变的，只需要设置一次。剩下的变量$\theta_{h_k} 和 \theta_{i_k}$则是各处不相同。如之前所说，$\overline{cos} \theta_{i_k}$需要使用$l_k和n$的点积来计算，并约束到[0,1]范围。类似的$\overline{cos} \theta_{h_k}$ 则是$h_k和n$的点积并约束范围。

视线向量*v*可以使用表面点*p*和观察点$p_v$来计算：

$$
v = \frac{p_v - p}{\Vert p_v - p \Vert}.   \tag{5.14}
$$

接下来，可以使用等式5.7来计算$h_k$。需要注意的是，所有的点和向量都需要在同一个空间下，我们使用的是世界空间。

最后的变量是表面法线*n*。不同位置的*n*的值是模型几何描述的一部分。每个三角形都有唯一的一个表面法线，着色器中直接使用三角形的法线也是可能有用途的。不过三角网格经常用于表现曲面。因此，模型描述中每个顶点都包含表面法线的定义（12.3.4节会介绍如何计算顶点法线）。图5.14中展示了两个不同的三角曲面，一个平滑，一个尖锐。

![图](/images/RTR3.05.14.png)
图5.14

至此，我们已经知道所有着色公式的相关计算。下面是一个实现这个的着色函数：

``` c
float3 Shade(float3 p,
             float3 n,
             uniform float3 pv,
             uniform float3 Kd,
             uniform float3 Ks,
             uniform float m,
             uniform unit lightCount,
             uniform float3 l[MAXLIGHTS],
             uniform float3 EL[MAXLIGHTS])
{
    float3 v = normalize(pv - p);
    float3 Lo = float3(0,0f, 0,0f, 0.0f);
    for (unit k = 0; k < lightCount; k++)
    {
        float3 h = normalize(v + l[k]);
        float cosTh = saturate(dot(n,h));
        float cosTi = saturate(dot(n, l[k]));
        Lo += (Kd + Ks * pow(cosTh, m)) * EL[k] * cosTi;  // 书上多了一个左括号
    }
    return Lo;
}
```

被标记为`uniform`的参数，在整个模型的计算过程中都是不变的。变量*p*和*n*则是每个顶点，每个像素都不同，取决于这个函数是顶点着色函数还是像素着色函数。函数`saturate`把它的参数约束到[0,1]范围。本例中，不会超过1，所以就是仅仅约束到大于0，`saturate`函数在大部分硬件上要比通用的`max`函数快。`normalize`函数的内部就是用向量除以向量的长度，以得到一个单位长度的向量。

所以上面这个`Shade`函数应该以什么样的频率来调用呢？当使用了顶点法线的时候，对着色公式进行逐图元求值（也叫平面着色）就不太合适了，因为它会产生一种`切面化`的结果，而不是需要的平滑表现（见图5.17的左图）。逐顶点求值并使用线性插值产生的结果通常称为`高罗德着色(Gouraud shading[435])`。在`Gouraud`着色（有明显的条纹）实现中，顶点着色器会将世界坐标线的顶点法线和位置传给*Shade()*(首先要保证*n*是单位向量)，然后把结果存入一个要被插值的变量中。像素着色器会获取插值后的值，并直接写入输出。`Gouraud`着色能渲染出可信的粗糙表面，但是更高要求的高光就显的有点假了，可以见图5.15和5.17中间的图。

![图](/images/RTR3.05.15.png)
图5.15. 逐顶点求值的着色，效果取决于顶点密度布局。上面的球从左到右包含的三角形数量为256，1024，16384个。

这种不真实感是对非线性的光照参数进行线性插值引起的。这也是为什么不真实感更容易在高光部分出现，因为高光部分的光线参数更加的不线性。

与`Grouaud`着色相对的极端是，完全使用`逐像素求值`着色。这通常称为`Phone shading[1014]`。这个实现中，顶点着色器把世界空间下的法线和位置写入插值的字段，像素着色处理之后传给*Shade()*。返回值则写入输出。需要主要的是：<font color="tomato">即便在顶点着色器中把表面法线处理成单位向量，插值也可能会改变它的长度，所以很有必要在像素着色器中再处理一次</font>。见图5.16。

![图](/images/RTR3.05.16.png)
图5.16. 对单位长度的法线进行线性插值，结果向量的长度会小于1.

`Phong shading`不会有插值产生的不真实感（见图5.17最右），不过就是相对来说比较耗。有一种这种混合的方法，就是部分计算放在顶点着色器上，另一些则逐像素计算。当被插值的数据比较线性的时候，这个方法就能够使用，并且不会明显导致渲染质量下降。

着色公式的实现跟下面几个部分相关：决定哪些部分可以简化；变量计算的频率如何选择；用户是否能够改变或控制最终表现。本节基于理论实现了一个模型的表现，不过忽略了一些物理现象。后面的章节会展现更加精美炫酷的着色效果。接下来的几节的内容会包括采样和过滤，透明以及gamma矫正。

![图](/images/RTR3.05.17.png)
图5.17。平面，Gouraud, 以及Phong着色。 平面着色没有包含高光，表面的光线也比较分散。Gouraud着色的高光也不完全，因为使用的是顶点计算高光。




