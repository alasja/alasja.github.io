---
title: "3.3 可着色编程的发展"
keywords: sample homepage
tags: [getting_started]
sidebar: rtr
layout: book
permalink: rtr_ch3_shader_evol.html
summary: GPU
---

### 3.3 可着色编程的发展
可编程着色框架的想法是1984年Cook的着色树提出的(shade trees[194])。图3.3显示了一个简单着色器的着色树。

![图](/images/RTR3.03.03.png)

RenderMan着色语言[30,1283]就是从这个想法中诞生出来，它从80年代末被创造，到今天依然广泛的应用在电影产品的渲染。在GPU本身支持可编程着色器之前，人们多次尝试在实时领域用多个渲染Pass来实现可编程着色操作。在1999年，《雷神之锤3：竞技场》的脚本化语言是这方面首次广泛成功的例子。在2000年，Peercy 等人描述一种将RenderMan着色器转换成图像硬件上多Pass执行的系统。他们发现GPU缺少两种能让这个方法通用特性：<font color="tomato">一是把计算结果当做纹理坐标来对待（依赖纹理的读取），二是在纹理和颜色缓冲中更大的范围和精度的数据类型的支持。</font>比方说16位浮点精度的数据。这个时候还有没有商业的GPU支持可编程着色，他们基本都支持高度可配置化。

2001年初，`NVIDIA GeForce 3`还是第一款支持可编程顶点着色器的GPU，需要DX8.0以及OpenGL扩展来运行。这些着色器使用类汇编语言来编写，然后在驱动上被转换成微代码。Dx8.0也支持像素着色器，但是它的实际编程能力很弱，这种非常受限的程序被驱动转换成纹理混合状态，一起被传递给寄存器组合。它的长度也是受限的（不超过12条指令），还受限于另外两个因素（纹理读取和浮点数据），正如Peercy等人前面提到的可编程的关键因素。

这个时期的着色器是不支持分支结构的，所以条件分支需要使用选择或者插值两个分支的结果来模拟。DX定义了`着色模型`的概念来区分硬件的不同着色能力。`GeForce 3`支持顶点着色模型1.1，像素着色模型1.1（支持着色模型1.0硬件并不存在）。在2001年，GPU已经离一个通用像素着色器编程模型非常近。DX8.1增加了像素着色模型从1.2到1.4（每个都代表不同的硬件），扩展了像素着色器的能力，增加了新的指令以及对纹理读取的支持。

2002年发布的DX9.0正式版包含了着色模型2.0（以及扩展版本2.X），它已经真正支持了可编程的顶点和像素着色器。OpenGL使用一些扩展也支持了通用的功能。增加了对纹理读取已经16位浮点数值得支持，完整实现了Peercy等人提出的需求定义。着色器上的有限资源如指令、纹理数量、以及寄存器都变多了，所以着色器有了表现更炫酷特效的能力。分支控制也开始支持了。着色器变动越来越复杂，使用汇编来编写着色器基本不太可能了。好在DX9.0也提供了一种新的着色编程语言，就是`HLSL(High Level Shading Language)`。HLSL是微软和NVIDIA联合开发的，它还有个跨平台的变体叫Cg。同时期，OpenGL ARB(Architecture Review Board)也发布了OpenGL使用的类似的语言，叫`GLSL(也叫GLslang)`。这些语言深受c语言的语法和设计哲学影响，也包含了一些RenderMan的元素。

2004年发布的着色模型3.0有着非常大的提升，一些可选的特性变成了必需的，更多的资源增加，以及顶点着色器中支持了纹理的访问。2005年末(微软XBox360)跟2006年(所以PS3)出来的新一代游戏主机基本都使用着色模型3.0。不过固定管线也还没完全挂，任天堂在2006年末发布的Wii就还是使用的固定管线。不过这可能是最后一代支持固定管线的主机了，现如今，就连手机这种移动设备都支持可编程着色器了（详见18.4.3）

还有一些其他的语言和环境来开发着色器。举个例子，Sh语言可以使用一个C++库来组合生成着色器。这个开源项目在很多平台上都能用。另一方面，不少可视化工具（一般没法类C语言来编写）能让设计师设计着色器。这些工具会包含一些可视工具来连接预定义的着色块，以及最终输出HLSL的着色结果。图3.4展示了这种工具的截图（Mental mill,包含来`NVIDIA FX Composer2`中），McGuire等人制作的可视工具，目标是提供高度抽象的扩展。

接下来的一个重大进步发生在2007年。着色模型4.0（DX10.0中，以及OpenGL的扩展中）包含了一些主要特性，比如几何着色器和流输出。

着色模型4.0中，所有的着色器（顶点、像素、几何着色器）包含一个统一的编程模型，就是前面提到的通用着色核心。可用资源得到更大的提升，增加了整型数据的支持（包括位操作）。需要注意的是着色模型4.0仅在高级着色语言中支持（`DX的HLSL和OpenGL的GLSL`），与前面的着色模型不同的是，它已经没有用户可以使用的汇编接口，

GPU供应商、微软已经OpenGL ARB组织持续不断的改进编程着色等能力。另外，新的API，新的编程模型，如NVIDIA的CUDA和AMD的CTM，面向的是非图形应用。这部分内容会在18.3.1进一步讨论。

### 3.3.1 着色模型的比较
虽然这章集中在着色模型4.0上（写本书时最新的），但通常开发者还是需要支持低版本的硬件。基于这个原因，我们会给出最近的几个着色模型（4.0，3.0以及2.0）的能力简短比较。列举所有的不同就超出了本书的范围，细节可以查看微软的MSDN以及DX SDK。

这里我们使用DX来对比，为什么呢，OpenGL发展出了不同等级的扩展，有些是ARB一致赞成的，有些却是开发商特有的。这个扩展系统对于使用某些开发特别支持的边缘特性非常有用，能够非常迅速的投入使用。DX
9及之前的版本也支持这种IHV（独立硬件供应商特性），它使用位属性来测试当前GPU是否支持某个特性。DX10中，微软就明确的移除这种操作方式，并且定义了各供应商必须支持的标准模型。尽管这里说的是DX，下面的内容同样适用于OpenGL，因为同时期的各个GPU基本都有着相同的特性。

![图](/images/RTR3.03.01t.png)
表3.1

表3.1中对比一个不同的着色模型。在这个表中，`VS`表示顶点着色器（`vertex shade`)，`PS`表示像素着色器(`pixel shader`)（4.0中发展处的几何着色器，同这些顶点着色器能力类似）。如果某一行既没有VS，也没有PS，那么那一行同时对顶点和像素着色器有效。因为虚拟机是4路SIMD，每个寄存器可以保存1到4个相关的数值。`Instruction Slots`表示着色器能够使用的指令的最大数量。`Max. Steps Executed`表示可执行的最大指令数量，说的是分支和循环中的部分。`Temp. Registers`表示能够存储结果的通用寄存器数量。`Constant Registers`则是表示能够传递给着色器的常量的数量。`Flow Control, Predication`表示计算条件表达式和执行循环或判断分支的能力（也就是条件执行或跳过指令的能力）。`Textures`表示周色漆能访问的独立纹理数量（详见第六章）。`Integer Support`表示整型数据操作和位操作等能力。`VS Input Registers`表示顶点着色器能够访问的可变寄存器数量。`Interpolator Registers`是顶点着色器的输出寄存器，也是像素着色器的输入寄存器。之所以叫插值寄存器是因为，顶点着色器的输出数据在被传递给像素着色器之前都会被基于三角形来插值。最后，`PS Output Registers`表示像素着色器可用的输出寄存器的数量，他们每一个都代表不同的缓冲，或者渲染目标(render target)。

