---
title: "3.6 像素着色器"
keywords: sample homepage
tags: [getting_started]
sidebar: rtr
layout: book
permalink: rtr_ch3_pixel.html
summary: GPU
---

### 3.6 像素着色器
在顶点和几何着色器操作之后，图元就已经被裁剪和设置好来做栅格化了，如前面的章节所说。流水线的这个部分的操作步骤比较固定，不可编程。它会遍历每个三角形，以及对整个三角形区域根据三个顶点数据来插值。下一个可编程阶段是像素着色器。它在OpenGL中叫做片元着色器，从某种角度来说，这个名字更加贴切。因为三角形可能完全或部分覆盖一个像素点，材质也有透明或者不透明。栅格器不直接作用在像素如何存储颜色上，而是生成数据来描述三角形是如何覆盖像素点的。等到合并期间，图元中存储的数据就会用来修正像素存储的数据。

一般来说顶点着色器的输出会作为像素着色器的输入数据。在着色模型4.0中，从顶点着色器最多可以传递`16`个向量（每个向量最多有四个值）到像素着色器。如果使用了几何着色器，它可以传递`32`个向量到像素着色器。

着色模型3.0中，像素着色器增加了一些特殊的输入数据。比方说，三角形的某一边是否可见也是一个输入数据。这一点对于面的正反需要绘制不同材质就很重要。片元的屏幕位置对于像素着色器也是可用的。

像素着色器的限制是它只能作用于当前片元。就是说，执行像素着色器的时候，它没法把结果传递给相邻的其他像素。<font color="tomato">所以说，它使用顶点的插值数据，以及常量数据和纹理数据，来计算单个像素的结果</font>。不过呢，这个限制也并非完全没有办法，相邻像素可以使用一些图像处理技术来互相影响，这将会在10.9节讨论。

有一种情况下，像素着色器可以访问相邻像素的信息（虽然不是直接的），就是计算渐变或导数信息的时候。像素着色器可以计算任何基于屏幕的xy轴变化的数值。这对很多计算和纹理坐标的计算都很有用。这个渐变对于过滤操作有特别的作用（见6.2.2）。大多数GPU实现这个特性的方式是对像素进行2x2或更大的组来处理。当像素着色器请求渐变数据的时候，将会返回相邻像素的差异。这种实现方式的一个影响是，渐变信息不能在像素着色器的分支结构中访问（就是if else之类的分支），整个组内的像素需要执行相同的指令。这是个基础限制，即便是离线渲染系统中也存在。访问渐变信息是像素着色器特有的能力，是其他任何可编程着色阶段都不具有的。

像素着色器一般都需要设置片元的颜色以供最后的合并阶段来使用。栅格阶段生成的深度数据也可以在像素着色器中修改。模板缓冲则无法修改，会直接传递到合并阶段。<font color="tomato">在着色模型2.0及以上，像素着色器可以丢弃掉一个片元数据，就是不输出任何东西。这个操作会影响性能，因为GPU上的一般优化就无法使用了，详见18.3.7</font>。在着色模型4.0中，雾计算和透明测试从合并操作中，转移到像素着色器的计算中了。

现在的像素着色器可以也有能力做大量的计算。在单个渲染`pass`中，计算任意数量的数值，这个能力引发了`multiple render targets(MRT)`多渲染目标的想法。像素着色器的计算结果不仅可以存储在单个颜色缓冲中，还可以为每个片元生成多个向量，并存储在不同的缓冲中。这些缓冲需要是相同的维度，在某些架构中，他们还需要有相同的位深度（不过可以视需求用不同的格式）。表3.1中提到的像素着色器输出寄存器数量，指的就是可访问的独立缓冲的数量，例如4或8个。与可显示的颜色缓冲不同，额外的渲染目标还有其他的限制。比方说，通常没法做抗锯齿。即便有这些限制，MRT功能也是一个表现更好效果的强力工具。如果同一份数据，要计算出很多中间结果图像，那么只需要一个渲染`pass`，而不用为每个输出一个`pass`。<font color="tomato">MRT的另一个重要功能是把这些结果图像作为纹理来读取。</font>
